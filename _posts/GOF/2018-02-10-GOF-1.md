---
layout: post
title:  "GOF의 디자인 패턴, 1장 디자인 패턴 기술하기"
author: Aeee
date:   2018-04-29 14:29:49 +0900
categories: GOF
tags: ECMAScript6+ javacript GOF Design Pattern
image: /assets/images/GOF.jpg
---

다음은 1장에서 디자인패턴에 대한 내용과 알고 넘어가야할 내용입니다.

# 디자인 패턴 기술하기
이 책에서 디자인 패턴을 설명하기 위해서 다음 템플릿에 따라서 구분하여 정의했습니다.

## 패턴 이름과 분류(Pattern Name and Classification)
 하나의 패턴에 붙는 이름은 그 자체가 핵심을 간결하게 전달해 줍니다. 이 것은 패턴에서 뿐만 어느 분야에서의 작명이 중요한 이름입니다. 그래서 좋은 이름은 패턴(모든 작명)의 생명입니다. 하지만 이 작명이 제일 어렵습니다?

## 의도(Intent)
 다음 질문들의 간결한 답을 제시하는 부분입니다.
 - 이 대장니 패턴은 무엇을 하는 것일까요?
 - 의도와 논리적인 근거가 무엇일까요?
 - 어떤 특정한 문제나 이슈를 해결하기 위한 것 일까요?

## 다른 이름(Also known As)
 이 패턴을 다르게 부르는 이름이 있다면, 그것을 제시합니다.

## 동기(Motivation)
 설계 문제를 제시하고, 패턴 안에서 클래스나 객체 구조가 어떻게 문제를 해결하는지 설명해 주는 일종의 시나리오입니다.

## 활용성(Applicability)
 해당 패턴을 어떤 사황에 적용할 수 있을까요? 패턴이 문제로 삼는 잘못된 설계의 예는 무엇일까요? 이 상황을 어떻게 파악할 수 있을까요?

## 구조(Structure)
 객체 모델링 기법에 기반을 둔 표기법을 이용하여 해당 패턴에서 쓰는 클래스들을 시각적을 나타냅니다. 보통 UML(Unified Modeling Language)로 표현 합니다.

## 참여자(Participant)
 주어진 패턴을 구성하고 책임을 수행하는 클래스나 객체들을 설명합니다.

## 협력방법(Cooalboration)
 참여자들이 작업을 수행하기 위한 참여자들 간의 협력 관계를 정의합니다.

## 결과(Consequence)
 - 이 패턴이 자산의 목표를 어떻게 지원할까요?
 - 이 패턴을 이용한 결과는 무엇이고 장단점은 무엇일까요?
 - 이 패턴을 사용하면 시스템 구조의 어떤 면을 독립적으로 다양화시킬 수 있을까요?

## 구현(Implementation)
 패턴을 구현할 때 주의해야 할 함정, 힌트, 기법 등은 무엇일까요? 특정 언어에 국한된 특이 사항은 무엇일까요?

## 예제 코드(Sample Code)
 주어진 패턴을 실제로 JS를 이용해서 어떻게 구현할 수 있는가를 보여주는 코드입니다.

## 잘 알려진 사용예(Known Use)
 소개되는 패턴들은 다양한 영역에서 사용되고 있습니다. 서로 다른 개발 분야에서 쓰는 예제르 두 가지 이상과 실제 시스템에서 찾아볼 수 있는 패턴들의 예를 포합시켰습니다.

## 관련 패턴
 이 패턴과 밀접하게 관련된 다른 패턴들은 무엇일까요? 이들의 중요한 차이점은 무엇일까요?

# 디자인 패턴의 사용 이유

## 특정 클래스에서 객체 생성
객체를 생성할 때 크랠스 이름을 명시하면 어떤 특정 인터페이스가 아닌 어떤 특정 구현에 종속된다. 이런 종속은 앞으로의 어떤 변화를 수용하지 못합니다. 이를 방지하려면 객체를 직접 생성해서는 안됩니다.
디자인 패턴: 추상 팩토리, 팩토리 메서드, 원형

## 특정 연산에 대한 의존성
특정한 연산을 사용하면, 요청을 만족하는 한 가지 방법에만 메이게 됩니다. 요청의 처리 방법을 직접 코딩하는 방식을 피하면, 컴파일 시점과 런타임 모드를 만족하면서 요청 처리 방법을 쉽게 변경할 수 있습니다.
디자인 패턴: 책임 연쇄, 명령

## 하드웨어와 소프트웨어 플랫폼에 대한 의존성
기본ㄴ에 존재하는 시스템 인터페이스와 응용프로그램 프로그래밍 인터페이스는 소프트웨어 및 하드웨어 플랫폼 마다 다릅니다. 특정 플랫폼에 종속된 소프트웨어는 다른 플랫폼에 이식하기도 어렵습니다. 또한 본래의 플랫폼에서도 버전의 변경을 따라가기 어려울수도 있습니다. 이런 플랫폼 종속성을 제거하는 것은 시스템 설계에 있어 매우 중요합니다.
디자인 패턴: 추상 팩토리, 브릿지

## 객체의 표현이나 구현에 대한 의존성
사용자가 객체의 표현 방법, 저장 방법, 구현 방법, 존재의 위치에 대한 모든 방법을 알고 있다면 객체를 변경할 때 사용자도 함께 변경해야합니다. 이런 정보를 사용자에게 감춤으로써 변화의 파급을 막을 수 있습니다.
디자인 패턴: 추상 팩토리, 브릿지, 메멘토, 프록시

## 알고리즘 의존성
알고리즘 자체를 확장할 수도 최적화할 수도, 다른 것으로 대체할 수도 있는데, 알고리즘에 종속된 객체라면 알고리즘이 변할 때마다 객체도 변경해야 합니다. 그러므로 변경이 가능한 알고리즘은 분리해 내는 것이 바람직합니다.
디자인 패턴: 빌더, 반복자, 전략, 템플릿 메서드, 방분자

## 높은 결합도
높은 결합도를 갖는 클래스들은 독립적으로 재사용하기 어렵습니다. 높은 결함도를 갖게 된다면 하나의 커다란 시스템이 되어 버립니다. 이렇게 되면 클래스 하나를 수정하기 위해서 전체를 이해해야 하고 다른 많은 클래스도 변경해야합니다. 또한 시스템은 배우기도 힘들고, 이식은 커넝 유지보수하기조차도 어려운 공룡이 되어 버립니다.
약한 결합도는 클래스 자체의 재사용을 가능하게 하고 시스템의 이해와 수정, 확장이 용이해서 이식성을 증대시킵니다. 추상 클래스 수준에서 결합도를 정의한다거나 계층화시키는 방법으로 디자인 퍁너은 낮은 결합도의 시스템을 만들도록 합니다.
디자인 패턴: 추상 팩토리, 브릿지, 책임 연쇄, 명령, 퍼사드, 중재자, 감시자

## 서브클래싱을 통한 기능 확장
서브클래싱으로 객체를 재정의하는 것은 쉬운 일이 아닙니다. 새로운 클래스마다 매번 반드시 해야 하는 초기화, 소멸 등에 대한 구현 오버헤드를 늘 지게 됩니다. 서브클래스를 정의하려면, 최상위 클래스부터 자신의 직속 부모 클래스까지 모든 것을 이해하고 있어야 합니다. 
일반적으로 객체 합성과 위임은 행동 조합을 위한 상속보다 훨씬 유연한 방법입니다. 기존 객체들을 새로운 방식으로 조합함으로써 새로운 서브클래스를 정의하지 않고도 응용 프로그램에 새로운 기능성을 추가할 수 있습니다. 한편, 객체 합성을 많이 사용하는 시스템은 이해하기가 어려워집니다. 많은 디자인 패턴에서는 그냥 서브클래스를 정의하고 다른 인스턴스와 새로 정의한 클래스의 인스턴스를 합성해서 기능을 재정의하는 방법을 도입힙니다.
디자인 패턴: 브릿지, 책임 연쇄, 장식자, 감시자, 전략

## 클래스 변경이 편하지 못한 점
가끔 클래스를 변경하는 작업이 그렇게 단순하지 않을 때가 있습니다. 소스 코드가 필요한데 없다고 가정해 봅시다. 또한 어떤 변경을 하면 기존의 서브클래스의 다수를 수정해야 한다고 가정합시다. 디자인 패턴은 이런 환경에서 클래스를 수정하는 방법을 제시합니다.
디자인 패턴: 적응자, 장식자, 방문자