---
layout: post
title:  "GOF의 디자인 패턴, 구조 패턴 2"
author: Aeee
date:   2021-09-30 14:29:49 +0900
categories: GOF
tags: GOF Design Pattern
image: /assets/images/GOF.jpg
---

# 구조 패턴 2


## 퍼사드 (FACADE)

<img style="width:100%" src="/assets/images/pattern/facade.png">

### 의도
한 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴으로, 서브시스템을 사용하기
쉽도록 상위 수준의 인터페이스를 제공합니다.

### 활용성

1. 복잡한 서브시스템에 대한 단순한 인터페이스를 제공이 필요할 때, 시스템 범위가 확정되면, 또한 구체적으로 설계
되면 서브시스템은 계속 복잡해집니다. 또한 패턴을 적용하면 확정성을 고려하여 설게하기 때문에, 작은 클래스가 만들어
집니다. 이런 과정은 서브시스템을 재사용 가능한 것으로 만들어 주고, 재정의할 수 있는 단위가 되도록 해 주기도 하지만,
실제 이런 상세한 재설계나 정제의 내용까지 파악할 필요가 없는 개발자에게 복잡해진 각가의 클래스들을 다 이해하면서
서브시스템을 사용하기란 어려운 일입니다. 이럴 때 퍼사드패턴은 서브시슽메에 대한 단순하면서도 기본적인 인터페이스를
제공함으로써 대부분의 개발자에게 적합한 클래스 형태를 제공합니다.
2. 추상 개념에 대한 구현 클래스와 사용자 사이에 너무 많은 종속성이 존재할 때, 퍼사드의 사용을 통해 사용자와 다른
서브시스템 간의 결합도를 줄일 수 있습니다. 즉, 서브시스템에 정의된 모든 인터페이스가 공개되면 빈번한 메서드 호출이
있을 수 있으나, 이런 호출은 단순한 형태로 통합하여 제공하고 나머지 부분은 내부적으로 처맇마으로써 사용자의 서브시스템
사이의 호횟수는 실질적으로 감소하게되는 효과를 갖습니다.
3. 서브시스템에을 계층화시킬 때, 퍼사드 패턴을 사용하여 각 서브시스템의 계층에 대한 접근점을 제공합니다. 서브시스템이
다른 서브시스템에 종솢거이라 하더라도, 각자가 제공하는 퍼사드를 통해서만 대화를 진행하게 함으로써 서브시스템의 간의
종석성을 줄일 수 있습니다. 이로써 서브시스템 내부 설계의 변경이 다른 서브시스템에 독립적으로 자유롭게 될 수 있을 것 입니다.


### 결과

1. 서브 시스템의 구성요소를 보호할 수 있습니다.
2. 서브시스템과 사용자 코드간의 결합도를 더욱 약하게 만듭니다.
3. 응용프로그램 쪽에서 서브시스템 클래스를 사용하는 것을 완전히 막지는 않습니다. 그러므로 퍼사드 패턴을 사용
할지 서비시스템 클래스를 직접 사용할지 결정할 수 있습니다.


## 플라이급 (FLYWEIGHT)

<img style="width:100%" src="/assets/images/pattern/facade.png">

### 의도
공유(sharing)를 통해 많은 수의 소립 객체들을 효과적으로 지원합니다.

### 활용성

1. 응용프로그램이 대량의 객체를 사용해야 할 때
2. 객체의 수가 너무 많아져 저장 비용이 너무 높아질 때
3. 대부분의 객체 상태를 부가적인 것으로 만들 수 있을 때
4. 부가적인 속성들을 제거한 후 객체들을 조사해 보니 객체의 많은 묶음이 비교적 적은 수의 공유된 객체로 대체될 수
있을 때, 현재 서로다른 객체로 간주한 이유는 이들 부가적인 속성 때문이었지 본질이 달랐던 것은 아닐 때
5. 응용프로그램이 객체의 정체성에 의존하지 않을 때, 플라이급 객체들은 공유 될 수 있음을 의미하는데, 식별자가
있다는 것은 서로 다른 객체로 구별해야 한다는 의미이므로 플라이급 객체를 사용할 수 없습니다.

### 결과

1. 공유해야 하는 인스턴스의 전체 수를 줄일 수 있습니다.
2. 객체별 본질적 상태의 양을 줄일 수 있습니다.
3. 부가적인 상태는 연산되거나 저장될 수 있습니다.


## 프록시 (PROXY)

<img style="width:100%" src="/assets/images/pattern/proxy.png">

### 의도
다른 객체에 대한 접근을 제한하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둡니다.

### 활용성

1. 원격지 프록시(remote proxy)는 서로 다른 주소 공간에 존재하는 객체를 가리키는 대표 객체로, 로컬 환경에 
위치합니다. NEXTSTEP[Add94]은 이런 목목적의 NXProxy 클래스를 사용하며, 코플리엔[Cop92]은 이런 종류의
프록시를 가리켜 "대사(Ambassador)"라고 하였습니다.
2. 가장 프록시(virtual proxy)는 요청이 있을 때만 필요한 고비용 개체를 생성합니다. 앞에서 예로 들었던
ImageProxy가 여기에 해당합니다.
3. 보효용 프록시(Protection proxy)는 원래 객체에 대한 설제 접근을 제어합니다. 이는 객체별로 접근 제어
권한이 다를 때ㅑ 유영하게 사용할 수 있습니다. 예를 들어, Choices 운영체제[CIRM93]의 KernelProXtes는 운영
체제 객체에 대한 보호된 접근을 할 수 있도록 합니다.
4. 스마트 참조자(smart reference)는 원시 포인터의 대체용 객체로, 실제 객체에 접근이 일어날 때 추가적인 행동을
수행합니다. 전형적인 사용예는 다음과 같습니다. <br/>
(1) 실제 객체에 대한 참조 횟수를 저장하다가 더는 참조가 없을 때 해당 객체를 자동으로 없앱니다.(스마트 포인터) <br/> 
(2) 맨처음 참조되는 시점에 영속적 저장소의 객체를 메모리로 옮깁니다. <br/>
(3) 실제 객체에 접근하기 전에, 다른 객체가 그것을 변경하지 못하도록 실제 객체에 대해 잠금(lock)을 겁니다. <br/>

### 결과

1. 원격지 프록시는 객체가 다른 주소 공간에 존재한다는 사실을 숨길 수 있습니다.
2. 가상 프록시는 요구에 따라 객체를 생성하는 등 처리를 최적화할 수 있습니다.
3. 보호용 프록시 및 스마트 참조자는 객체가 접근할 때마다 추가 관리를 책임집니다. 객체를 생성할 것인지
삭제할 것인지를 관리합니다.

   